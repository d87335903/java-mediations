第1章 引言<br>
第2章 创建和销毁对象<br>
第1条：考虑用静态工厂方法代替构造器<br>
第2条：遇到多个构造器参数时要考虑用构建器<br>
第3条：用私有构造器或者枚举类型强化Singleton属性<br>
第4条：通过私有构造器强化不可实例化的能力<br>
第5条：避免创建不必要的对象<br>
第6条：消除过期的对象引用<br>
第7条：避免使用终结方法<br>

第3章 对于所有对象都通用的方法<br>
第8条：覆盖equals时请遵守通用约定(继续)<br>
第9条：覆盖equals时总要覆盖hashCode<br>
第10条：始终要覆盖toString<br>
第11条：谨慎地覆盖clone<br>
第12条：考虑实现Comparable接口<br>

第4章 类和接口<br>
第13条：使类和成员的可访问性最小化<br>
第14条：在公有类中使用访问方法而非公有域<br>
第15条：使可变性最小化<br>
第16条：复合优先于继承<br>
第17条：要么为继承而设计，并提供文档说明，要么就禁止继承<br>
第18条：接口优于抽象类<br>
第19条：接口只用于定义类型<br>
第20条：类层次优于标签类<br>
第21条：用函数对象表示策略<br>
第22条：优先考虑静态成员类<br>

第5章 泛型<br>
第23条：请不要在新代码中使用原生态类型<br>
第24条：消除非受检警告<br>
第25条：列表优先于数组<br>
第26条：优先考虑泛型<br>
第27条：优先考虑泛型方法<br>
第28条：利用有限制通配符来提升API的灵活性<br>
第29条：优先考虑类型安全的异构容器<br>

第6章 枚举和注解<br>
第30条：用enum代替int常量<br>
第31条：用实例域代替序数<br>
第32条：用EnumSet代替位域<br>
第33条：用EnumMap代替序数索引<br>
第34条：用接口模拟可伸缩的枚举<br>
第35条：注解优先于命名模式<br>
第36条：坚持使用Override注解<br>
第37条：用标记接口定义类型<br>

第7章 方法<br>
第38条：检查参数的有效性<br>
第39条：必要时进行保护性拷贝<br>
第40条：谨慎设计方法签名<br>
第41条：慎用重载<br>
第42条：慎用可变参数<br>
第43条：返回零长度的数组或者集合，而不是：null<br>
第44条：为所有导出的API元素编写文档注释<br>

第8章 通用程序设计<br>
第45条：将局部变量的作用域最小化<br>
第46条：for-each循环优先于传统的for循环<br>
第47条：了解和使用类库<br>
第48条：如果需要精确的答案，请避免使用float和double<br>
第49条：基本类型优先于装箱基本类型<br>
第50条：如果其他类型更适合，则尽量避免使用字符串<br>
第51条：当心字符串连接的性能<br>
第52条：通过接口引用对象<br>
第53条：接口优先于反射机制<br>
第54条：谨慎地使用本地方法<br>
第55条：谨慎地进行优化<br>
第56条：遵守普遍接受的命名惯例<br>

第9章 异常<br>
第57条：只针对异常的情况才使用异常<br>
第58条：对可恢复的情况使用受检异常，对编程错误使用运行时异常<br>
第59条：避免不必要地使用受检的异常<br>
第60条：优先使用标准的异常<br>
第61条：抛出与抽象相对应的异常<br>
第62条：每个方法抛出的异常都要有文档<br>
第63条：在细节消息中包含能捕获失败的信息<br>
第64条：努力使失败保持原子性<br>
第65条：不要忽略异常<br>

第10章 并发<br>
第66条：同步访问共享的可变数据<br>
第67条：避免过度同步<br>
第68条：executor和task优先干线程<br>
第69条：并发工具优先于wait和notify<br>
第70条：线程安全性的文档化<br>
第71条：慎用延迟初始化<br>
第72条：不要依赖于线程调度器<br>
第73条：避免使用线程组<br>

第11章 序列化<br>
第74条：谨慎地实现Serializable接口<br>
第75条：考虑使用自定义的序列化形式<br>
第76条：保护性地编写readObject方法<br>
第77条：对于实例控制，枚举类型优先于readResolve<br>
第78条：考虑用序列化代理代替序列化实例<br>
